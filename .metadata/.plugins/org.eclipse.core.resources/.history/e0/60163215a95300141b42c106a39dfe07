package com.example.myfrebble;

import static com.microsoft.windowsazure.mobileservices.MobileServiceQueryOperations.*;

import java.net.MalformedURLException;
import java.util.List;

import android.app.Activity;
import android.app.AlertDialog;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.ProgressBar;

import com.microsoft.windowsazure.mobileservices.MobileServiceClient;
import com.microsoft.windowsazure.mobileservices.MobileServiceTable;
import com.microsoft.windowsazure.mobileservices.NextServiceFilterCallback;
import com.microsoft.windowsazure.mobileservices.ServiceFilter;
import com.microsoft.windowsazure.mobileservices.ServiceFilterRequest;
import com.microsoft.windowsazure.mobileservices.ServiceFilterResponse;
import com.microsoft.windowsazure.mobileservices.ServiceFilterResponseCallback;
import com.microsoft.windowsazure.mobileservices.TableOperationCallback;
import com.microsoft.windowsazure.mobileservices.TableQueryCallback;

import com.microsoft.windowsazure.mobileservices.MobileServiceUser;
import com.microsoft.windowsazure.mobileservices.MobileServiceAuthenticationProvider;
import com.microsoft.windowsazure.mobileservices.UserAuthenticationCallback;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;

import java.util.concurrent.atomic.AtomicBoolean;

import com.microsoft.windowsazure.notifications.NotificationsManager;
import com.microsoft.windowsazure.mobileservices.Registration;
import com.microsoft.windowsazure.mobileservices.RegistrationCallback;

public class ToDoActivity extends Activity {

	/**
	 * Mobile Service Client reference
	 */
	private MobileServiceClient mClient;

	/**
	 * Mobile Service Table used to access data
	 */
	private MobileServiceTable<ToDoItem> mToDoTable;

	/**
	 * Adapter to sync the items list with the view
	 */
	private ToDoItemAdapter mAdapter;

	/**
	 * EditText containing the "New ToDo" text
	 */
	private EditText mTextNewToDo;

	/**
	 * Progress spinner to use for table operations
	 */
	private ProgressBar mProgressBar;
	
	public static final String SHAREDPREFFILE = "temp"; 
	public static final String USERIDPREF = "uid";  
	public static final String TOKENPREF = "tkn";
	
	// These will be used to help synchronize the authentication of the user.
	// We only want to authenticate once. Any calls during an authentication
	// should wait and use the new token from the authentication in progress.
	public boolean bAuthenticating = false;
	public final Object mAuthenticationLock = new Object();
	
	public static final String SENDER_ID = "481058621174";

	/**
	 * Initializes the activity
	 */
	// In this code the RefreshTokenCacheFilter is used in addition to the ProgressFilter.
	// Also during onCreate we want to load the token cache. So false is passed in to the
	// authenticate method.
	@Override
	public void onCreate(Bundle savedInstanceState) {
	    super.onCreate(savedInstanceState);

	    setContentView(R.layout.activity_to_do);
	    mProgressBar = (ProgressBar) findViewById(R.id.loadingProgressBar);

	    // Initialize the progress bar
	    mProgressBar.setVisibility(ProgressBar.GONE);

	    try {
	        // Create the Mobile Service Client instance, using the provided
	        // Mobile Service URL and key
	        mClient = new MobileServiceClient(
	        		"https://myfrebble.azure-mobile.net/",
					"hqJxCKJqKdVwOInmcuEIYnMgwguXDF57", this)
	                   .withFilter(new ProgressFilter())
	                   .withFilter(new RefreshTokenCacheFilter());
	        
	        // Authenticate passing false to load the current token cache if available.
	        //authenticate(false);

	        // Register the notification handler class.
	        NotificationsManager.handleNotifications(this, SENDER_ID, MyHandler.class);
	        
	    } catch (MalformedURLException e) {
	        createAndShowDialog(new Exception("Error creating the Mobile Service. " +
	            "Verify the URL"), "Error");
	    }
	}
	
	/**
	 * Initializes the activity menu
	 */
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		getMenuInflater().inflate(R.menu.activity_main, menu);
		return true;
	}
	
	/**
	 * Select an option from the menu
	 */
	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		if (item.getItemId() == R.id.menu_refresh) {
			refreshItemsFromTable();
		}
		
		return true;
	}

	/**
	 * Mark an item as completed
	 * 
	 * @param item
	 *            The item to mark
	 */
	public void checkItem(ToDoItem item) {
		if (mClient == null) {
			return;
		}

		// Set the item as completed and update it in the table
		item.setComplete(true);
		
		mToDoTable.update(item, new TableOperationCallback<ToDoItem>() {

			public void onCompleted(ToDoItem entity, Exception exception, ServiceFilterResponse response) {
				if (exception == null) {
					if (entity.isComplete()) {
						mAdapter.remove(entity);
					}
				} else {
					createAndShowDialog(exception, "Error");
				}
			}

		});
	}

	/**
	 * Add a new item
	 * 
	 * @param view
	 *            The view that originated the call
	 */
	public void addItem(View view) {
		if (mClient == null) {
			return;
		}

		// Create a new item
		ToDoItem item = new ToDoItem();

		item.setText(mTextNewToDo.getText().toString());
		item.setComplete(false);
		
		// Insert the new item
		mToDoTable.insert(item, new TableOperationCallback<ToDoItem>() {

			public void onCompleted(ToDoItem entity, Exception exception, ServiceFilterResponse response) {
				
				if (exception == null) {
					if (!entity.isComplete()) {
						mAdapter.add(entity);
					}
				} else {
					createAndShowDialog(exception, "Error");
				}

			}
		});

		mTextNewToDo.setText("");
	}

	/**
	 * Refresh the list with the items in the Mobile Service Table
	 */
	private void refreshItemsFromTable() {

		// Get the items that weren't marked as completed and add them in the
		// adapter
		mToDoTable.where().field("complete").eq(val(false)).execute(new TableQueryCallback<ToDoItem>() {

			public void onCompleted(List<ToDoItem> result, int count, Exception exception, ServiceFilterResponse response) {
				if (exception == null) {
					mAdapter.clear();

					for (ToDoItem item : result) {
						mAdapter.add(item);
					}

				} else {
					createAndShowDialog(exception, "Error");
				}
			}
		});
	}

	/**
	 * Creates a dialog and shows it
	 * 
	 * @param exception
	 *            The exception to show in the dialog
	 * @param title
	 *            The dialog title
	 */
	private void createAndShowDialog(Exception exception, String title) {
		Throwable ex = exception;
		if(exception.getCause() != null){
			ex = exception.getCause();
		}
		createAndShowDialog(ex.getMessage(), title);
	}

	/**
	 * Creates a dialog and shows it
	 * 
	 * @param message
	 *            The dialog message
	 * @param title
	 *            The dialog title
	 */
	private void createAndShowDialog(String message, String title) {
		AlertDialog.Builder builder = new AlertDialog.Builder(this);

		builder.setMessage(message);
		builder.setTitle(title);
		builder.create().show();
	}
	
	private class ProgressFilter implements ServiceFilter {
		
		@Override
		public void handleRequest(ServiceFilterRequest request, NextServiceFilterCallback nextServiceFilterCallback,
				final ServiceFilterResponseCallback responseCallback) {
			runOnUiThread(new Runnable() {

				@Override
				public void run() {
					if (mProgressBar != null) mProgressBar.setVisibility(ProgressBar.VISIBLE);
				}
			});
			
			nextServiceFilterCallback.onNext(request, new ServiceFilterResponseCallback() {
				
				@Override
				public void onResponse(ServiceFilterResponse response, Exception exception) {
					runOnUiThread(new Runnable() {

						@Override
						public void run() {
							if (mProgressBar != null) mProgressBar.setVisibility(ProgressBar.GONE);
						}
					});
					
					if (responseCallback != null)  responseCallback.onResponse(response, exception);
				}
			});
		}
	}
	
	// This creates a new method to handle the authentication process. The user is authenticated
	// by using a Google login. A dialog is displayed which displays the ID of the authenticated
	// user. You cannot proceed without a positive authentication.
	// EDIT: Updated the authenticate method so that it accepts a boolean parameter to allow forcing
	// the refresh of the token and token cache. We also need to notify any blocked threads when
	// authentication is completed so they can pick up the new token.
	/**
	 * Authenticates with the desired login provider. Also caches the token. 
	 * 
	 * If a local token cache is detected, the token cache is used instead of an actual 
	 * login unless bRefresh is set to true forcing a refresh.
	 * 
	 * @param bRefreshCache
	 *            Indicates whether to force a token refresh. 
	 */
	private void authenticate(boolean bRefreshCache) {

	    bAuthenticating = true;

	    if (bRefreshCache || !loadUserTokenCache(mClient))
	    {
	        // New login using the Google provider and update the token cache.
			// NOTE
			// If you are using an identity provider other than Google, change the value passed to the
			// login method above to one of the following: MicrosoftAccount, Facebook, Twitter, or
	    	// windowsazureactivedirectory.
	        mClient.login(MobileServiceAuthenticationProvider.Google,
	                new UserAuthenticationCallback() {
	                    @Override
	                    public void onCompleted(MobileServiceUser user,
	                            Exception exception, ServiceFilterResponse response) {

	                        synchronized(mAuthenticationLock)
	                        {
	                            if (exception == null) {
	                                cacheUserToken(mClient.getCurrentUser());
	                                createTable();
	                            } else {
	                                createAndShowDialog(exception.getMessage(), "Login Error");
	                            }
	                            bAuthenticating = false;
	                            mAuthenticationLock.notifyAll();
	                        }
	                    }
	                });
	    }
	    else
	    {
	        // Other threads may be blocked waiting to be notified when 
	        // authentication is complete.
	        synchronized(mAuthenticationLock)
	        {
	            bAuthenticating = false;
	            mAuthenticationLock.notifyAll();
	        }
	        createTable();
	    }
	}
	
	// Moved the remaining code after authenticate(); in the onCreate method to a new createTable method.
	private void createTable() {
        
	    // Get the Mobile Service Table instance to use
	    mToDoTable = mClient.getTable(ToDoItem.class);

	    mTextNewToDo = (EditText) findViewById(R.id.textNewToDo);

	    // Create an adapter to bind the items with the view
	    mAdapter = new ToDoItemAdapter(this, R.layout.row_list_to_do);
	    ListView listViewToDo = (ListView) findViewById(R.id.listViewToDo);
	    listViewToDo.setAdapter(mAdapter);

	    // Load the items from the Mobile Service
	    refreshItemsFromTable();
	}
	
	// This method stores the user id and token in a preference file that is marked private.
	// This should protect access to the cache so that other apps on the device do not have
	// access to the token because the preference is sandboxed for the app. However, if someone
	// gains access to the device, it is possible that they may gain access to the token cache
	// through other means.
	// NOTE:
	// You can further protect the token with encryption if token access to your data is considered
	// highly sensitive and someone may gain access to the device. However, a completely secure
	// solution is beyond the scope of this tutorial and dependent on your security requirements.
	private void cacheUserToken(MobileServiceUser user)
	{
	    SharedPreferences prefs = getSharedPreferences(SHAREDPREFFILE, Context.MODE_PRIVATE);
	    Editor editor = prefs.edit();
	    editor.putString(USERIDPREF, user.getUserId());
	    editor.putString(TOKENPREF, user.getAuthenticationToken());
	    editor.commit();
	}
	
	private boolean loadUserTokenCache(MobileServiceClient client)
	{
	    SharedPreferences prefs = getSharedPreferences(SHAREDPREFFILE, Context.MODE_PRIVATE);
	    String userId = prefs.getString(USERIDPREF, "undefined"); 
	    if (userId == "undefined")
	        return false;
	    String token = prefs.getString(TOKENPREF, "undefined"); 
	    if (token == "undefined")
	        return false;

	    MobileServiceUser user = new MobileServiceUser(userId);
	    user.setAuthenticationToken(token);
	    client.setCurrentUser(user);

	    return true;
	}
	
	// The following method will be used to block outbound calls on other threads while
	// authentication is in progress.
	/**
	 * Detects if authentication is in progress and waits for it to complete. 
	 * Returns true if authentication was detected as in progress. False otherwise.
	 */
	public boolean detectAndWaitForAuthentication()
	{
	    boolean detected = false;
	    synchronized(mAuthenticationLock)
	    {
	        do
	        {
	            if (bAuthenticating == true)
	                detected = true;
	            try
	            {
	                mAuthenticationLock.wait(1000);
	            }
	            catch(InterruptedException e)
	            {}
	        }
	        while(bAuthenticating == true);
	    }
	    if (bAuthenticating == true)
	        return true;

	    return detected;
	}
	
	// This method will actually trigger the wait and then update the token on outbound
	// requests when authentication is complete.
	/**
	 * Waits for authentication to complete then adds or updates the token 
	 * in the X-ZUMO-AUTH request header.
	 * 
	 * @param request
	 *            The request that receives the updated token.
	 */
	private void waitAndUpdateRequestToken(ServiceFilterRequest request)
	{
	    MobileServiceUser user = null;
	    if (detectAndWaitForAuthentication())
	    {
	        user = mClient.getCurrentUser();
	        if (user != null)
	        {
	            request.removeHeader("X-ZUMO-AUTH");
	            request.addHeader("X-ZUMO-AUTH", user.getAuthenticationToken());
	        }
	    }
	}
	
	// This service filter will check each response for HTTP status code 401 "Unauthorized".
	// If a 401 is encountered, a new login request to obtain a new token will be setup on
	// the UI thread. Other calls will be blocked until the login is completed. Once the new
	// token is obtained, the request that triggered the 401 will be retried with the new token
	// and any blocked calls will be retried with the new token.
	/**
	 * The RefreshTokenCacheFilter class filters responses for HTTP status code 401. 
	 * When 401 is encountered, the filter calls the authenticate method on the 
	 * UI thread. Out going requests and retries are blocked during authentication. 
	 * Once authentication is complete, the token cache is updated and 
	 * any blocked request will receive the X-ZUMO-AUTH header added or updated to 
	 * that request.   
	 */
	private class RefreshTokenCacheFilter implements ServiceFilter {

	    AtomicBoolean mAtomicAuthenticatingFlag = new AtomicBoolean();

	    /**
	     * The AuthenticationRetryFilterCallback class is a wrapper around the response 
	     * callback that encapsulates the request and other information needed to enable 
	     * a retry of the request when HTTP status code 401 is encountered. 
	     */
	    private class AuthenticationRetryFilterCallback implements ServiceFilterResponseCallback
	    {
	        // Data members used to retry the request during the response.
	        ServiceFilterRequest mRequest;
	        NextServiceFilterCallback mNextServiceFilterCallback;
	        ServiceFilterResponseCallback mResponseCallback;

	        public AuthenticationRetryFilterCallback(ServiceFilterRequest request, 
	                NextServiceFilterCallback nextServiceFilterCallback, 
	                ServiceFilterResponseCallback responseCallback)
	        {
	            mRequest = request;
	            mNextServiceFilterCallback = nextServiceFilterCallback;
	            mResponseCallback = responseCallback;
	        }

	        @Override
	        public void onResponse(ServiceFilterResponse response, Exception exception) {

	            // Filter out the 401 responses to update the token cache and 
	            // retry the request
	            if ((response != null) && (response.getStatus().getStatusCode() == 401))
	            { 
	                // Two simultaneous requests from independent threads could get HTTP 
	                // status 401. Protecting against that right here so multiple 
	                // authentication requests are not setup to run on the UI thread.
	                // We only want to authenticate once. Other requests should just wait 
	                // and retry with the new token.
	                if (mAtomicAuthenticatingFlag.compareAndSet(false, true))                           
	                {
	                    // Authenticate on UI thread
	                    runOnUiThread(new Runnable() {
	                        @Override
	                        public void run() {
	                            // Force a token refresh during authentication.
	                            authenticate(true);
	                        }
	                    });
	                }

	                // Wait for authentication to complete then 
	                // update the token in the request.
	                waitAndUpdateRequestToken(this.mRequest);
	                mAtomicAuthenticatingFlag.set(false);                       

	                // Retry recursively with a new token as long as we get a 401.
	                mNextServiceFilterCallback.onNext(this.mRequest, this);
	            }

	            // Responses that do not have 401 status codes just pass through.
	            else if (this.mResponseCallback != null)  
	              mResponseCallback.onResponse(response, exception);
	        }
	    }

	    @Override
	    public void handleRequest(final ServiceFilterRequest request, 
	        final NextServiceFilterCallback nextServiceFilterCallback,
	        ServiceFilterResponseCallback responseCallback) {

	        // In this example, if authentication is already in progress we block the request
	        // until authentication is complete to avoid unnecessary authentications as 
	        // a result of HTTP status code 401. 
	        // If authentication was detected, add the token to the request.
	        waitAndUpdateRequestToken(request);

	        // Wrap the request in a callback object that will facilitate retries.
	        AuthenticationRetryFilterCallback retryCallbackObject = 
	            new AuthenticationRetryFilterCallback(request, nextServiceFilterCallback,
	                  responseCallback); 

	        // Send the request down the filter chain.
	        nextServiceFilterCallback.onNext(request, retryCallbackObject);         
	    }
	}
	
	// The following method allows registering for notifications.
	/**
	 * Registers mobile services client to receive GCM push notifications
	 * @param gcmRegistrationId The Google Cloud Messaging session Id returned 
	 * by the call to GoogleCloudMessaging.register in NotificationsManager.handleNotifications
	 */
	public void registerForPush(String gcmRegistrationId)
	{
	  mClient.getPush().register(gcmRegistrationId,null,new RegistrationCallback()
	  {
	    @Override
	    public void onRegister(Registration registration, Exception exception)
	      {
	        if (exception != null)
	        {
	          // handle exception
	        }
	      }
	  });
	}
}
